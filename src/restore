#!/usr/bin/env bash

# Prevent input from being read by the wrong process(es).
exec 6<&0 0</dev/null

IFS='.' read -r type name ignore <<< "${HOSTNAME}"
component="$(echo "${type}_${name}" | awk '{print toupper($0)}')"
pass="${component}_PASS"
user="${component}_USER"
unset type name ignore component

# Ensure there are no connections while restoring by shutting down and switching
# ports during the restore process.

# switch ports
sed -i 's/5432/5433/g' /data/var/db/postgresql/postgresql.conf
# stop postgres
sv down db
if [[ ! ( pg_ctl stop -w -D /data/var/db/postgresql -m f ) ]]; then
  pg_ctl stop -w -D /data/var/db/postgresql -m i
fi
# bring postgres back up on the temporary port
if [[ -e /etc/service/db/run ]]; then
  sv up db
fi
# ensure we can actually reach the server at the temporary port
let count=0
while [[ "$(netstat -an | egrep ':5433' | grep LISTEN)" = "" ]]; do
  sleep 1
  let count++
  if [[ count -ge 10 ]]; then
    exit 1
  fi
done
until PGPASSWORD="${!pass}" /data/bin/psql -U ${!user} -p 5433 postgres -c "SELECT * FROM pg_catalog.pg_tables;"
do
  sleep 1
done

# Perform the actual restoration!
PGPASSWORD="${!pass}" /data/bin/psql -U ${!user} -p 5433 postgres <&6
result=$?

# Close the temporary file handle.
exec 6<&-

# Resume normal operation.

# switch ports
sed -i 's/5433/5432/g' /data/var/db/postgresql/postgresql.conf
# stop postgres
sv down db
if [[ ! pg_ctl stop -w -D /data/var/db/postgresql -m f ]]; then
  pg_ctl stop -w -D /data/var/db/postgresql -m i
fi
# bring postgres back up on the standard port
if [[ -e /etc/service/db/run ]]; then
  sv up db
fi
# ensure we can actually reach the server at the standard port
let count=0
while [[ "$(netstat -an | egrep ':5432' | grep LISTEN)" = "" ]]; do
  sleep 1
  let count++
  if [[ count -ge 10 ]]; then
    exit 1
  fi
done
until PGPASSWORD="${!pass}" /data/bin/psql -U ${!user} -p 5432 postgres -c "SELECT * FROM pg_catalog.pg_tables;"
do
  sleep 1
done

exit $result
